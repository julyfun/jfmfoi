# NOIP难度指针选择题

## 题目1
以下关于指针的描述，错误的是：
```c
int a = 10;
int *p = &a;
```
A) `*p` 表示变量a的值  
B) `p` 存储的是变量a的地址  
C) `&p` 表示指针变量p的地址  
D) `*p` 可以修改指针p指向的地址  

<details>
<summary>正确答案</summary>
D) `*p` 可以修改指针p指向的地址  
解析：`*p` 表示解引用，可以修改a的值，但不能修改p指向的地址。要修改p指向的地址，应该直接对p赋值。
</details>

## 题目2
以下代码的输出结果是：
```c
int arr[] = {1, 2, 3};
int *p = arr;
printf("%d", *(p + 1));
```
A) 1  
B) 2  
C) 3  
D) 编译错误  

<details>
<summary>正确答案</summary>
B) 2  
解析：p指向数组首元素，p+1指向第二个元素，解引用得到2。
</details>

## 题目3
以下哪项是指向指针的指针的正确声明方式？
A) `int **pp;`  
B) `int *p*;`  
C) `int &*p;`  
D) `int (*)p;`  

<details>
<summary>正确答案</summary>
A) `int **pp;`  
解析：指向指针的指针需要使用两个星号声明。
</details>

## 题目4
以下代码的输出结果是：
```c
int a = 5, b = 10;
int *p1 = &a, *p2 = &b;
*p1 = *p2;
printf("%d %d", a, b);
```
A) 5 10  
B) 10 10  
C) 5 5  
D) 10 5  

<details>
<summary>正确答案</summary>
B) 10 10  
解析：`*p1 = *p2` 将b的值赋给了a，所以a变为10，b保持不变。
</details>

## 题目5
以下代码的输出结果是：
```c
int x = 5;
int *ptr = &x;
int **pptr = &ptr;
**pptr = 20;
printf("%d", x);
```
A) 5  
B) 20  
C) 指针地址  
D) 编译错误  

<details>
<summary>正确答案</summary>
B) 20  
解析：通过双重指针`**pptr`修改了x的值，最终x变为20。
</details>

## 题目6
以下代码的输出结果是：
```c
char str[] = "NOIP";
char *p = str;
printf("%c", *(p + 2));
```
A) N  
B) O  
C) I  
D) P  

<details>
<summary>正确答案</summary>
C) I  
解析：p指向字符串首字符，p+2指向第三个字符'I'。
</details>

## 题目7
以下哪项可以正确交换两个整数的值？
```c
void swap(int *a, int *b) {
    // 填入代码
}
```
A) `int *temp = a; a = b; b = temp;`  
B) `int temp = *a; *a = *b; *b = temp;`  
C) `int *temp = *a; *a = *b; *b = *temp;`  
D) `int temp = a; a = b; b = temp;`  

<details>
<summary>正确答案</summary>
B) `int temp = *a; *a = *b; *b = temp;`  
解析：需要通过指针解引用来交换实际变量的值，而不是交换指针本身。
</details>

---

# NOIP难度二进制编码、原码、反码、补码选择题

## 题目1
在8位二进制表示中，+5的原码、反码和补码分别是：
A) 00000101, 00000101, 00000101  
B) 00000101, 11111010, 11111011  
C) 10000101, 11111010, 11111011  
D) 10000101, 01111010, 01111011  

<details>
<summary>正确答案</summary>
A) 00000101, 00000101, 00000101  
解析：正数的原码、反码和补码都相同，最高位为符号位0表示正数。
</details>

## 题目2
在8位二进制补码表示中，-7的表示形式是：
A) 10000111  
B) 11111001  
C) 11111000  
D) 10000110  

<details>
<summary>正确答案</summary>
B) 11111001  
解析：+7的原码是00000111，反码是11111000，补码是反码加1得到11111001。
</details>

## 题目3
以下关于补码的描述，错误的是：
A) 补码解决了0的表示不唯一问题  
B) 补码的加减运算可以直接使用加法器完成  
C) 补码表示中，正数和负数的范围不对称  
D) 补码的符号位可以参与运算  

<details>
<summary>正确答案</summary>
C) 补码表示中，正数和负数的范围不对称  
解析：补码表示中，负数比正数多一个（如8位补码范围是-128~127），这是正确的特性，不是错误描述。
</details>

## 题目4
在8位二进制补码表示中，10000000表示的十进制数是：
A) -0  
B) -127  
C) -128  
D) 128  

<details>
<summary>正确答案</summary>
C) -128  
解析：8位补码中10000000表示-128，这是补码表示的特殊情况。
</details>

## 题目5
以下哪种编码方式最适合用于计算机中的整数运算？
A) 原码  
B) 反码  
C) 补码  
D) 移码  

<details>
<summary>正确答案</summary>
C) 补码  
解析：补码统一了加减法运算，解决了0的表示不唯一问题，是现代计算机整数运算的标准表示方法。
</details>





